/*
>>Creational Design Patterns
Creational patterns deal with object creation mechanisms, optimizing how objects are created to suit particular situations.

.Singleton Pattern
(The Singleton pattern restricts the instantiation of a class to a single instance. This is useful when exactly one object is needed to coordinate actions across the system.)
.Factory Pattern
(The Factory pattern provides an interface for creating objects in a superclass but allows subclasses to alter the type of objects that will be created.)
*/

/*
>>Structural Design Patterns
Structural patterns simplify the design by identifying a simple way to realize relationships between entities.
.Modular Pattern
(The Module pattern is used to create a self-contained block of code that can expose certain properties or methods while keeping others private.)
.Decorator Pattern
(The Decorator pattern is used to add responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.)

*/

/*
>>Behavioral Design Patterns
Behavioral patterns focus on how objects interact and communicate with each other.
.Observer Pattern
(The Observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.)
.Strategy Pattern
(The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. It lets the algorithm vary independently from the clients that use it)
*/

/*
Adapter Pattern
(
The Adapter Pattern allows objects with incompatible interfaces to work together. It acts as a bridge between two interfaces, converting one interface into another that a client expects.

Use Cases: When integrating with third-party libraries or APIs that donâ€™t match your current interface, or when dealing with legacy code that needs to be adapted for newer systems.
)
*/
